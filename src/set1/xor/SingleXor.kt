package set1.xor

// The most common letters in English plain texts. Probably overkill for this challenge; just " " would have sufficed.
private const val COMMON_LETTERS = " \netaoinshrdlu"

/* Set 1, Challenge 3. A given cipher text is generated by XORing a cipher key against the plain text. Find both. */
object SingleXor {
  /* <String>.score() "scores" the receiver object, so to speak, using " ETAOINSHRDLU" as the weights, in that decreasing
   *   order of importance. The frequency analysis on these characters alone should be enough to crack simple ciphers.
   */
  fun String.score(): Int =
    COMMON_LETTERS.withIndex().fold(0, { acc, (i, ch) -> acc + (26 - i) * this.count { it == ch } })

  /* <String>.toAscii() converts the receiver object from a hexadecimal representation to the equivalent ASCII (7-bit)
   *   representation by patching them in chunks/groups of two.
   * Requires: The receiver object consists of only hexadecimal characters, i.e. only [0-9] and [a-f] as constituents.
   */
  fun String.toAscii(): String {
    val len = this.length
    if (len % 2 != 0) throw IllegalArgumentException("$this contains an odd number of hex characters.")

    val result = Array(len/2, { "" })
    for (i in 0 until len step 2) {
      result[i/2] = "" + this[i] + this[i+1]
    }

    return result.fold("", { acc, s -> acc + s.toInt(16).toChar().toString() })
  }

  /* decrypt(msg) decrypts the cipher text [msg] by considering each ASCII character as a candidate for the cipher key
   *   and scoring the result of XORing for each one. The key with the highest score is returned in a pair, along with
   *   the corresponding recovered plain text (in ASCII) as the second element of the pair.
   * Requires: [msg] consists of only hexadecimal characters, i.e. only [0-9] and [a-f] as constituents.
   */
  fun decrypt(msg: String): Pair<Char,String> {
    var max = 0
    var key = 0.toChar()
    var result = ""
    val keys = Array(128, { it }) // All valid ASCII characters.

    for (k in keys) {
      val len = if (k < 16) msg.length else msg.length / 2
      val kei = k.toString(16).repeat(len) // Create a repeating form of the byte payload as a cipher key.
      val str = FixedXor.join(msg, kei).toAscii() // XOR the cipher key and cipher text and observe the result in ASCII.
      val score = str.score() // Score the resulting plain text.
      if (score > max) {
        max = score
        key = k.toChar()
        result = str
      }
    }

    return Pair(key, result)
  }
}